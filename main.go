package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
)

// Provisioned by ldflags.
var version string

const deprecationComment = "// Deprecated: Do not use."

const (
	contextPackage = protogen.GoImportPath("context")
)

func main() {
	options := protogen.Options{}

	options.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			generateFile(gen, f)
		}

		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	fileName := file.GeneratedFilenamePrefix + "_kit.pb.go"
	g := gen.NewGeneratedFile(fileName, file.GoImportPath)

	g.P("// Code generated by protoc-gen-go-kit. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-go-kit ", version)
	g.P("// - protoc            ", protocVersion(gen))
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	generateFileContent(file, g)
}

// generateFileContent generates the gRPC service definitions, excluding the package statement.
func generateFileContent(file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	for _, service := range file.Services {
		genService(g, service)
	}
}

func genService(g *protogen.GeneratedFile, service *protogen.Service) {
	handlerName := service.GoName + "Handler"

	g.AnnotateSymbol(handlerName, protogen.Annotation{Location: service.Location})

	g.P("// ", handlerName, " which should be called from the gRPC binding of the service")
	g.P("// implementation. The incoming request parameter, and returned response")
	g.P("// parameter, are both gRPC types, not user-domain.")
	g.P("//")
	g.P("// This interface is based on github.com/go-kit/kit/transport/grpc.Handler.")
	g.P("type ", handlerName, " interface {")
	g.P("ServeGRPC(ctx ", g.QualifiedGoIdent(contextPackage.Ident("Context")), ", request interface{}) (", g.QualifiedGoIdent(contextPackage.Ident("Context")), ", interface{}, error)") // nolint: lll
	g.P("}")

	serverName := service.GoName + "KitServer"

	g.P("// ", serverName, " is the Go kit server implementation for ", service.GoName, " service.")

	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}

	g.AnnotateSymbol(serverName, protogen.Annotation{Location: service.Location})

	g.P("type ", serverName, " struct {")
	g.P("Unimplemented", service.GoName, "Server")
	g.P()
	for _, method := range service.Methods {
		g.AnnotateSymbol(serverName+"."+method.GoName, protogen.Annotation{Location: method.Location})
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			g.P(deprecationComment)
		}
		g.P(method.GoName, "Handler ", handlerName)
	}
	g.P("}")
	g.P()

	for _, method := range service.Methods {
		g.P(method.Comments.Leading, "func (s ", serverName, ") ", serverSignature(g, method), "{")
		g.P("_, resp, err := s.", method.GoName, "Handler.ServeGRPC(ctx, req)")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P()
		g.P("return resp.(*", g.QualifiedGoIdent(method.Output.GoIdent), "), nil")
		g.P("}")
		g.P()
	}
}

func serverSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	reqArgs := []string{
		"ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context")),
		"req *" + g.QualifiedGoIdent(method.Input.GoIdent),
	}
	ret := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"

	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}

	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}

	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}
